/* ###################################################################
**     This component module is generated by Processor Expert. Do not modify it.
**     Filename    : AT24C164.c
**     Project     : EA076_PE
**     Processor   : MKL25Z128VLK4
**     Component   : 24AA_EEPROM
**     Version     : Component 01.032, Driver 01.00, CPU db: 3.00.000
**     Repository  : My Components
**     Compiler    : GNU C Compiler
**     Date/Time   : 2019-05-26, 01:22, # CodeGen: 294
**     Abstract    :
**         Driver for Microchip 24_AA/LC EEPROMs
**     Settings    :
**          Component name                                 : AT24C164
**          Device                                         : 16
**          Initial Device Address                         : 0x0
**          Block buffer size                              : 16
**          Acknowledge Polling                            : Enabled
**            Page Write Time (ms)                         : 10
**            Wait                                         : WAIT1
**            ACK Polling Time (us)                        : 18
**          Connection                                     : 
**            I2C                                          : GI2C1
**            Write Protection Pin                         : Disabled
**          Timeout                                        : Disabled
**          Shell                                          : Disabled
**     Contents    :
**         ReadByte          - byte AT24C164_ReadByte(AT24C164_Address addr, byte *data);
**         WriteByte         - byte AT24C164_WriteByte(AT24C164_Address addr, byte data);
**         ReadBlock         - byte AT24C164_ReadBlock(AT24C164_Address addr, byte *data, word dataSize);
**         WriteBlock        - byte AT24C164_WriteBlock(AT24C164_Address addr, byte *data, word dataSize);
**         SelectDevice      - byte AT24C164_SelectDevice(byte addrI2C);
**         GetSelectedDevice - byte AT24C164_GetSelectedDevice(void);
**
**     License   :  Open Source (LGPL)
**     Copyright : (c) Copyright Erich Styger, 2013, all rights reserved.
**     This an open source software implementation with Processor Expert.
**     This is a free software and is opened for education,  research  and commercial developments under license policy of following terms:
**     * This is a free software and there is NO WARRANTY.
**     * No restriction on use. You can use, modify and redistribute it for personal, non-profit or commercial product UNDER YOUR RESPONSIBILITY.
**     * Redistributions of source code must retain the above copyright notice.
** ###################################################################*/
/*!
** @file AT24C164.c
** @version 01.00
** @brief
**         Driver for Microchip 24_AA/LC EEPROMs
*/         
/*!
**  @addtogroup AT24C164_module AT24C164 module documentation
**  @{
*/         

/* MODULE AT24C164. */

#include "AT24C164.h"

static byte AT24C164_I2CAddress = (0&AT24C164_MAX_I2C_ADDR_MASK); /* current I2C address used */

/* macros for the control byte: */
#define AT24C164_CTRL_NBL       (0x0A<<3) /* control byte high nibble. Typically this is 1010 (shifted by one to the right) */
#if (AT24C164_DEVICE_ID==AT24C164_DEVICE_ID_8) || (AT24C164_DEVICE_ID==AT24C164_DEVICE_ID_16)
  #define AT24C164_CTRL_ADDR      0     /* no additional address bits */
  /* define control byte as 1010|Bx|B1|B0 */
  #define AT24C164_BANK_0         (0<<2) /* B0 bit (0) inside the CTRL_BYTE: 1010|B0|A1|A0 */
  #define AT24C164_BANK_1         (1<<2) /* B0 bit (1) inside the CTRL_BYTE: 1010|B0|A1|A0 */
  #define AT24C164_CTRL_BYTE      (AT24C164_CTRL_NBL|AT24C164_CTRL_ADDR) /* 1010|B0|A1|A0 */
  #define AT24C164_DEVICE_ADDR(addr) \
    ( AT24C164_CTRL_BYTE|((addr>>8)&0x07) )
  #if 0 /* old style */
    (((addr)&0x400)? \
        (AT24C164_CTRL_BYTE|AT24C164_BANK_1) \
      : (AT24C164_CTRL_BYTE|AT24C164_BANK_0) ) /* 7bit address of device used to select device */
  #endif
#elif (AT24C164_DEVICE_ID==AT24C164_DEVICE_ID_32) || (AT24C164_DEVICE_ID==AT24C164_DEVICE_ID_256) || (AT24C164_DEVICE_ID==AT24C164_DEVICE_ID_512)
  #define AT24C164_CTRL_ADDR      AT24C164_I2CAddress /* address inside control byte */
  /* define control byte as 1010|A2|A1|A0 */
  #define AT24C164_CTRL_BYTE         (AT24C164_CTRL_NBL|AT24C164_CTRL_ADDR) /* 1010|A2|A1|A0 */
  #define AT24C164_DEVICE_ADDR(addr) AT24C164_CTRL_BYTE /* 7bit address of device used to select device */
#elif AT24C164_DEVICE_ID==AT24C164_DEVICE_ID_1025
  #define AT24C164_CTRL_ADDR      AT24C164_I2CAddress /* address inside control byte */
  /* define control byte as 1010|Bx|A1|A0 */
  #define AT24C164_BANK_0         (0<<2) /* B0 bit (0) inside the CTRL_BYTE: 1010|B0|A1|A0 */
  #define AT24C164_BANK_1         (1<<2) /* B0 bit (1) inside the CTRL_BYTE: 1010|B0|A1|A0 */
  #define AT24C164_CTRL_BYTE      (AT24C164_CTRL_NBL|AT24C164_CTRL_ADDR) /* 1010|B0|A1|A0 */
  #define AT24C164_DEVICE_ADDR(addr) \
    (((addr)&0x10000)? \
        (AT24C164_CTRL_BYTE|AT24C164_BANK_1) \
      : (AT24C164_CTRL_BYTE|AT24C164_BANK_0) ) /* 7bit address of device used to select device */
#endif

/*
** ===================================================================
**     Method      :  AT24C164_WriteByte (component 24AA_EEPROM)
**     Description :
**         Writes a single byte to specified address
**     Parameters  :
**         NAME            - DESCRIPTION
**         addr            - The address inside the EEPROM
**         data            - The data value to write
**     Returns     :
**         ---             - Error code, possible values
**                           ERR_OK - OK
**                           otherwise it can return an error code of
**                           the underlying communication protocol.
** ===================================================================
*/
byte AT24C164_WriteByte(AT24C164_Address addr, byte data)
{
  uint8_t res, block[3];

  res = GI2C1_SelectSlave(AT24C164_DEVICE_ADDR(addr));
  if (res != ERR_OK) {
    (void)GI2C1_UnselectSlave();
    return res;
  }
  #if (AT24C164_DEVICE_ID==AT24C164_DEVICE_ID_8) || (AT24C164_DEVICE_ID==AT24C164_DEVICE_ID_16)
    block[0] = (uint8_t)(addr&0xff);    /* low byte of address */
    block[1] = data; /* switch to read mode */
    res = GI2C1_WriteBlock(block, 2, GI2C1_SEND_STOP); /* send address and data */
  #else
    block[0] = (uint8_t)(addr>>8);      /* high byte of address */
    block[1] = (uint8_t)(addr&0xff);    /* low byte of address */
    block[2] = data; /* switch to read mode */
    res = GI2C1_WriteBlock(block, sizeof(block), GI2C1_SEND_STOP); /* send address and data */
  #endif
  if (res != ERR_OK) {
    (void)GI2C1_UnselectSlave();
    return res;
  }
#if AT24C164_DO_ACKNOWLEDGE_POLLING
  /* do acknowledge polling */
  block[0] = 0xff; /* dummy value */
  do {
    WAIT1_WaitOSms(AT24C164_PAGE_WRITE_TIME_MS);
    res = GI2C1_ProbeACK(block, 1, GI2C1_SEND_STOP, AT24C164_ACK_POLLING_TIME_US); /* send address and data */
  } while(res!=ERR_OK); /* wait until we get an ACK */
#endif /* AT24C164_DO_ACKNOWLEDGE_POLLING */
  if (res != ERR_OK) {
    (void)GI2C1_UnselectSlave();
    return res;
  }
  return GI2C1_UnselectSlave();
}

/*
** ===================================================================
**     Method      :  AT24C164_ReadByte (component 24AA_EEPROM)
**     Description :
**         Reads a single byte from the given memory address
**     Parameters  :
**         NAME            - DESCRIPTION
**         addr            - The address where to read from memory.
**       * data            - Pointer to a location where to store the
**                           data
**     Returns     :
**         ---             - Error code, possible values
**                           ERR_OK - OK
**                           otherwise it can return an error code of
**                           the underlying communication protocol.
** ===================================================================
*/
byte AT24C164_ReadByte(AT24C164_Address addr, byte *data)
{
  uint8_t res;
  #if (AT24C164_DEVICE_ID==AT24C164_DEVICE_ID_8) || (AT24C164_DEVICE_ID==AT24C164_DEVICE_ID_16)
    uint8_t addr8;
    addr8 = (uint8_t)(addr&0xff); // low address byte
  #else
    uint8_t addr16[2];                  /* big endian address on I2C bus needs to be 16bit */

    addr16[0] = (uint8_t)(addr>>8); /* 16 bit address must be in big endian format */
    addr16[1] = (uint8_t)(addr&0xff);
  #endif

  res = GI2C1_SelectSlave(AT24C164_DEVICE_ADDR(addr));
  if (res != ERR_OK) {
    (void)GI2C1_UnselectSlave();
    return res;
  }
  #if (AT24C164_DEVICE_ID==AT24C164_DEVICE_ID_8) || (AT24C164_DEVICE_ID==AT24C164_DEVICE_ID_16)
    res = GI2C1_WriteBlock(&addr8, 1, GI2C1_DO_NOT_SEND_STOP); /* send 8bit address */
  #else /* use 16bit address */
    res = GI2C1_WriteBlock(addr16, 2, GI2C1_DO_NOT_SEND_STOP); /* send 16bit address */
  #endif
  if (res != ERR_OK) {
    (void)GI2C1_UnselectSlave();
    return res;
  }
  res = GI2C1_ReadBlock(data, 1, GI2C1_SEND_STOP); /* read data byte from bus */
  if (res != ERR_OK) {
    (void)GI2C1_UnselectSlave();
    return res;
  }
  return GI2C1_UnselectSlave();
}

/*
** ===================================================================
**     Method      :  AT24C164_ReadBlock (component 24AA_EEPROM)
**     Description :
**         Read a block of memory.
**     Parameters  :
**         NAME            - DESCRIPTION
**         addr            - Address where to read the memory
**       * data            - Pointer to a buffer where to store the
**                           data
**         dataSize        - Size of buffer the data pointer
**                           is pointing to
**     Returns     :
**         ---             - Error code, possible values
**                           ERR_OK - OK
**                           otherwise it can return an error code of
**                           the underlying communication protocol.
** ===================================================================
*/
byte AT24C164_ReadBlock(AT24C164_Address addr, byte *data, word dataSize)
{
  uint8_t res;
  #if (AT24C164_DEVICE_ID==AT24C164_DEVICE_ID_8) || (AT24C164_DEVICE_ID==AT24C164_DEVICE_ID_16)
    uint8_t addr8;
    addr8 = (uint8_t)(addr&0xff);
  #else
    uint8_t addr16[2];                  /* big endian address on I2C bus needs to be 16bit */
    addr16[0] = (uint8_t)(addr>>8); /* 16 bit address must be in big endian format */
    addr16[1] = (uint8_t)(addr&0xff);
  #endif

  res = GI2C1_SelectSlave(AT24C164_DEVICE_ADDR(addr));
  if (res != ERR_OK) {
    (void)GI2C1_UnselectSlave();
    return res;
  }
  #if (AT24C164_DEVICE_ID==AT24C164_DEVICE_ID_8) || (AT24C164_DEVICE_ID==AT24C164_DEVICE_ID_16)
    res = GI2C1_WriteBlock(&addr8, 1, GI2C1_DO_NOT_SEND_STOP); /* send 8bit address */
  #else
    res = GI2C1_WriteBlock(addr16, 2, GI2C1_DO_NOT_SEND_STOP); /* send 16bit address */
  #endif
  if (res != ERR_OK) {
    (void)GI2C1_UnselectSlave();
    return res;
  }
  res = GI2C1_ReadBlock(data, dataSize, GI2C1_SEND_STOP);
  if (res != ERR_OK) {
    (void)GI2C1_UnselectSlave();
    return res;
  }
  return GI2C1_UnselectSlave();
}

/*
** ===================================================================
**     Method      :  AT24C164_WriteBlockPage (component 24AA_EEPROM)
**
**     Description :
**         Writes a block with pages of data to the EEPROM
**         This method is internal. It is used by Processor Expert only.
** ===================================================================
*/
#ifdef __HIWARE__
#pragma MESSAGE DISABLE C1855 /* recursive function call */
#endif
byte AT24C164_WriteBlockPage(AT24C164_Address addr, byte *data, word dataSize)
{
  uint8_t res, i, *p, block[AT24C164_BLOCK_BUF_SIZE+2]; /* additional 2 bytes for the address */
  uint16_t eepromPage = (uint16_t)(addr/AT24C164_PAGE_SIZE);
  uint8_t offset = (uint8_t)(addr%AT24C164_PAGE_SIZE);

  if (dataSize==0 || dataSize>AT24C164_BLOCK_BUF_SIZE) {
    return ERR_OVERFLOW;                /* you may increase the buffer size in the properties? */
  }
  if (dataSize>AT24C164_PAGE_SIZE) {
    uint16_t size;

    size = (uint16_t)(AT24C164_PAGE_SIZE-offset);
    if (size!=0) {
      res = AT24C164_WriteBlock(addr, data, size); /* first page write */
      if (res != ERR_OK) {
        return res;
      }
      data += size; /* increment data pointer */
      addr += size; /* increment address */
      dataSize -= size; /* reduce size */
    }
    /* write multiple block of PAGE_SIZE */
    while (dataSize>AT24C164_PAGE_SIZE) {
      res = AT24C164_WriteBlock(addr, data, AT24C164_PAGE_SIZE);
      if (res != ERR_OK) {
        return res;
      }
      data += AT24C164_PAGE_SIZE; /* increment data pointer */
      addr += AT24C164_PAGE_SIZE; /* increment address */
      dataSize -= AT24C164_PAGE_SIZE; /* reduce size */
    }
    /* write remainder (if any) */
    if (dataSize>0) {
      return AT24C164_WriteBlock(addr, data, dataSize);
    }
    return ERR_OK;
  }
  if (offset+dataSize <= AT24C164_PAGE_SIZE) { /* no page boundary crossing */
    res = GI2C1_SelectSlave(AT24C164_DEVICE_ADDR(addr));
    if (res != ERR_OK) {
      (void)GI2C1_UnselectSlave();
      return res;
    }
    #if (AT24C164_DEVICE_ID==AT24C164_DEVICE_ID_8) || (AT24C164_DEVICE_ID==AT24C164_DEVICE_ID_16)
      /* 8 bit address byte, high byte of address have been place in SelectSlave(addr) */
      block[0] = (uint8_t)(addr&0xff);  /* low byte of address */
      p = &block[1]; i = (uint8_t)dataSize;
    #else /* 16 bit address byte */
      block[0] = (uint8_t)(addr>>8);    /* high byte of address */
      block[1] = (uint8_t)(addr&0xff);  /* low byte of address */
      p = &block[2]; i = (uint8_t)dataSize;
    #endif

    /* copy block */
    while(i>0) {
      *p++ = *data++;
      i--;
    }
    res = GI2C1_WriteBlock(block,
        dataSize+((AT24C164_DEVICE_ID==AT24C164_DEVICE_ID_8)||(AT24C164_DEVICE_ID==AT24C164_DEVICE_ID_16)? 1:2), GI2C1_SEND_STOP); /* send address and data */
    if (res != ERR_OK) {
      (void)GI2C1_UnselectSlave();
      return res;
    }
#if AT24C164_DO_ACKNOWLEDGE_POLLING
    /* do acknowledge polling */
    block[0] = 0xff; /* dummy value */
    do {
      WAIT1_WaitOSms(AT24C164_PAGE_WRITE_TIME_MS);
      res = GI2C1_ProbeACK(block, 1, GI2C1_SEND_STOP, AT24C164_ACK_POLLING_TIME_US); /* send address and data */
    } while(res!=ERR_OK); /* wait until we get an ACK */
    if (res != ERR_OK) {
      (void)GI2C1_UnselectSlave();
      return res;
    }
#endif /* AT24C164_DO_ACKNOWLEDGE_POLLING */
    return GI2C1_UnselectSlave();
  } else { /* crossing page boundaries: make two page writes */
    res = AT24C164_WriteBlock(addr, data, (uint16_t)(AT24C164_PAGE_SIZE-offset)); /* first page write */
    if (res != ERR_OK) {
      return res;
    }
    res = AT24C164_WriteBlock((AT24C164_Address)((eepromPage+1)*AT24C164_PAGE_SIZE),
       data+(AT24C164_PAGE_SIZE-offset),
       (uint16_t)(dataSize-(AT24C164_PAGE_SIZE-offset))); /* first page write */
    if (res != ERR_OK) {
      return res;
    }
  }
  return res;
}
#ifdef __HIWARE__
  #pragma MESSAGE DEFAULT C1855 /* recursive function call */
#endif

/*
** ===================================================================
**     Method      :  AT24C164_WriteBlock (component 24AA_EEPROM)
**     Description :
**         Writes a block of data to the EEPROM
**     Parameters  :
**         NAME            - DESCRIPTION
**         addr            - Address of memory
**       * data            - Pointer to the data
**         dataSize        - Size of data
**     Returns     :
**         ---             - Error code, possible values
**                           ERR_OK - OK
**                           ERR_OVERFLOW - data block passed has either
**                           size of zero or exceeds internal buffer
**                           size
**                           otherwise it can return an error code of
**                           the underlying communication protocol.
** ===================================================================
*/
byte AT24C164_WriteBlock(AT24C164_Address addr, byte *data, word dataSize)
{
  int32_t size;

  if (dataSize<=AT24C164_BLOCK_BUF_SIZE) { /* fits into internal buffer */
    return AT24C164_WriteBlockPage(addr, data, dataSize);
  }
  size = dataSize;
  while(size>=AT24C164_BLOCK_BUF_SIZE) { /* write in chunks AT24C164_BLOCK_BUF_SIZE */
    if (AT24C164_WriteBlock(addr, data, AT24C164_BLOCK_BUF_SIZE)!=ERR_OK) {
      return ERR_FAILED;
    }
    addr += AT24C164_BLOCK_BUF_SIZE;
    data += AT24C164_BLOCK_BUF_SIZE;
    size -= AT24C164_BLOCK_BUF_SIZE;
  }
  if (size>0) { /* write remainder which is < EE241_BLOCK_BUF_SIZE  */
    if (AT24C164_WriteBlockPage(addr, data, size)!=ERR_OK) {
      return ERR_FAILED;
    }
  }
  return ERR_OK;
}

/*
** ===================================================================
**     Method      :  AT24C164_SelectDevice (component 24AA_EEPROM)
**     Description :
**         Configures the I2C address to be used for the memory. With
**         this multiple devices attached to the bus can be addressed.
**     Parameters  :
**         NAME            - DESCRIPTION
**         addrI2C         - I2C Address of the memory device,
**                           formed by the address pins.
**     Returns     :
**         ---             - Error code, possible codes:
**                           ERR_OK - OK
**                           ERR_VALUE - address exceeds address pins of
**                           device type used
** ===================================================================
*/
byte AT24C164_SelectDevice(byte addrI2C)
{
  if (addrI2C>AT24C164_MAX_I2C_ADDR_MASK) {
    return ERR_VALUE;                   /* Device address too large for device address pins available. */
  }
  AT24C164_I2CAddress = addrI2C;
  return ERR_OK;
}

/*
** ===================================================================
**     Method      :  AT24C164_GetSelectedDevice (component 24AA_EEPROM)
**     Description :
**         Returns the currently used I2C address (e.g. set with
**         SelectDevice()).
**     Parameters  : None
**     Returns     :
**         ---             - I2C device address
** ===================================================================
*/
byte AT24C164_GetSelectedDevice(void)
{
 return AT24C164_I2CAddress;
}

/* END AT24C164. */

/*!
** @}
*/
/*
** ###################################################################
**
**     This file was created by Processor Expert 10.5 [05.21]
**     for the Freescale Kinetis series of microcontrollers.
**
** ###################################################################
*/
